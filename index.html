<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>рд▓рд╛рдЗрд╡ рдмрд╛рддрдЪреАрдд тАФ Mobile Robust</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 10px; font-family: Arial, sans-serif;
      background: #f9f9f9; text-align: center; overflow: hidden;
    }
    h2 {
      margin: 6px 0; padding: 8px; font-size: 17px;
      background:#fff8e1; color:#795548; border-radius:8px;
      border:1px solid #ffe0b2; line-height:1.25;
    }
    #output {
      width:100%; height:56vh; padding:12px;
      background:#fff; border-radius:10px; border:1px solid #ccc;
      text-align:left; font-size:26px; line-height:1.4;
      overflow-y:auto; white-space:pre-wrap;
    }
    .controls { margin-top:8px; }
    button {
      padding:10px 14px; margin:6px; font-size:20px;
      border-radius:8px; border:none; cursor:pointer; color:#fff;
    }
    #mic { background:#4caf50; }
    #live { background:#2196f3; }
    #stopLive { background:#ff9800; display:none; }
    #erase { background:#f44336; }
    .hint { margin-top:8px; font-size:13px; color:#666; }
  </style>
</head>
<body>

  <h2>ЁЯОд тАЬрдмреЛрд▓рд┐рдПтАЭ тАФ рдПрдХ рдмрд╛рд░ рдмреЛрд▓реЗрдВ тАв ЁЯОЩя╕П тАЬрд▓рд╛рдЗрд╡ рдмрд╛рддрдЪреАрддтАЭ тАФ рд▓рдЧрд╛рддрд╛рд░ рд╕реБрдиреЗрдВ</h2>

  <div id="output">рдпрд╣рд╛рдБ рдЖрдкрдХреА рдЖрд╡рд╛рдЬрд╝ рдХрд╛ рдЯреЗрдХреНрд╕реНрдЯ рджрд┐рдЦреЗрдЧрд╛...</div>

  <div class="controls">
    <button id="mic">ЁЯОд рдмреЛрд▓рд┐рдП</button>
    <button id="live">ЁЯОЩя╕П рд▓рд╛рдЗрд╡ рдмрд╛рддрдЪреАрдд</button>
    <button id="stopLive">тП╣ рд░реЛрдХрд┐рдП</button>
    <button id="erase">ЁЯз╣ рдорд┐рдЯрд╛рдЗрдП</button>
  </div>

  <div class="hint">рдпрджрд┐ рд╕рдорд╕реНрдпрд╛ рдлрд┐рд░ рднреА рдмрдиреА рд░рд╣реЗ рддреЛ рдореИрдВ рддреБрд░рдВрдд рдПрдХ рдЫреЛрдЯрд╛ debug build рджреЗ рджреВрдВрдЧрд╛ рдЬреЛ рд╕реНрдХреНрд░реАрди рдкрд░ raw events рджрд┐рдЦрд╛рдПрдЧрд╛ред</div>

  <script>
  (function() {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const output = document.getElementById('output');
    const btnMic = document.getElementById('mic');
    const btnLive = document.getElementById('live');
    const btnStop = document.getElementById('stopLive');
    const btnErase = document.getElementById('erase');

    if (!SpeechRecognition) {
      output.innerText = "рдЖрдкрдХрд╛ рдмреНрд░рд╛рдЙрдЬрд╝рд░ Speech Recognition рд╕рдкреЛрд░реНрдЯ рдирд╣реАрдВ рдХрд░рддрд╛ тАФ рдХреГрдкрдпрд╛ Chrome/Edge рдЙрдкрдпреЛрдЧ рдХрд░реЗрдВред";
      btnMic.disabled = btnLive.disabled = btnStop.disabled = true;
      return;
    }

    // ---- single-shot recognition (unchanged behavior) ----
    const singleRec = new SpeechRecognition();
    singleRec.lang = 'hi-IN';
    singleRec.interimResults = false;
    singleRec.maxAlternatives = 1;

    btnMic.addEventListener('click', () => {
      try { singleRec.start(); output.innerText = "ЁЯОЩя╕П рдорд╛рдЗрдХ рд╕реБрди рд░рд╣рд╛ рд╣реИ..."; }
      catch(e){ console.warn(e); }
    });

    singleRec.onresult = (ev) => {
      try { output.innerText = ev.results[0][0].transcript; } catch(e){ console.warn(e); }
    };
    singleRec.onerror = (ev) => { output.innerText = "тЪая╕П рддреНрд░реБрдЯрд┐: " + ev.error; };

    // ---- robust live recognition ----
    let sessionCounter = 0;
    let isLiveActive = false;
    let recognizing = false;    // true when a recognition session is active (onstart)
    let restarting = false;
    let restartAttempts = 0;
    const MAX_RESTARTS = 8;     // after many restarts, stop and show message
    const RESTART_DELAYS = [400, 800, 1200, 1600, 2000]; // backoff cycle
    let committedText = "";     // accumulated final text
    let recentFinals = new Map(); // normalizedText -> timestamp (ms)  (dedupe across sessions)
    let recentKeys = new Set();   // sessionKey (norm|resultIndex|session) to avoid duplicates
    const DEDUPE_WINDOW_MS = 5000; // treat same final as duplicate within 5s

    // normalize for comparison
    function normalize(s){
      return (s||'').trim().toLowerCase().replace(/\s+/g,' ');
    }
    function cleanupCaches(){
      const now = Date.now();
      for (const [k, ts] of recentFinals.entries()) {
        if (now - ts > DEDUPE_WINDOW_MS * 3) recentFinals.delete(k);
      }
      // limit recentKeys size
      if (recentKeys.size > 500) recentKeys = new Set([...recentKeys].slice(-300));
    }

    // create a fresh recognition each time to avoid internal state issues
    function createLiveRecognition(mySessionId) {
      const r = new SpeechRecognition();
      r.lang = 'hi-IN';
      r.interimResults = true;
      // continuous requested; mobile may not honor but we'll restart safely
      r.continuous = true;
      r._sessionId = mySessionId;
      return r;
    }

    // start a new recognition session safely
    let liveRec = null;
    function startNewSession() {
      if (recognizing) return;
      sessionCounter += 1;
      const sid = sessionCounter;
      liveRec = createLiveRecognition(sid);

      // event handlers
      liveRec.onstart = () => {
        recognizing = true;
        restartAttempts = 0;
        restarting = false;
        // console.log('session start', sid);
      };

      liveRec.onresult = (ev) => {
        cleanupCaches();
        try {
          const sid = liveRec._sessionId;
          let interimParts = [];
          for (let i = ev.resultIndex; i < ev.results.length; i++) {
            const res = ev.results[i];
            const txt = res[0] && res[0].transcript ? res[0].transcript.trim() : '';
            if (res.isFinal) {
              const norm = normalize(txt);
              // key to prevent duplicates across sessions/indices
              const key = norm + '|' + i + '|' + sid;
              // time-based dedupe by normalized text too
              const lastTs = recentFinals.get(norm) || 0;
              const now = Date.now();

              if (!recentKeys.has(key) && (norm && (now - lastTs > DEDUPE_WINDOW_MS))) {
                // append committed text
                committedText += (committedText ? ' ' : '') + txt;
                recentFinals.set(norm, now);
                recentKeys.add(key);
              } else {
                // duplicate detected; ignore
              }
            } else {
              if (txt) interimParts.push(txt);
            }
          }
          // display committed + interim
          const interimText = interimParts.length ? ("\n" + interimParts.join(' ')) : "";
          output.innerText = (committedText ? committedText : "") + interimText;
          output.scrollTop = output.scrollHeight;
        } catch (e) { console.warn('onresult error', e); }
      };

      liveRec.onerror = (ev) => {
        // ignore benign errors; for others increment restartAttempts
        if (ev && ev.error && ev.error !== 'no-speech' && ev.error !== 'aborted') {
          // log but don't spam the user
          output.innerText += "\nтЪая╕П рддреНрд░реБрдЯрд┐: " + ev.error;
        }
      };

      liveRec.onend = () => {
        recognizing = false;
        // if live still active, attempt restart with backoff but avoid overlaps
        if (!isLiveActive) return;
        if (restartAttempts >= MAX_RESTARTS) {
          isLiveActive = false;
          btnStop.style.display = 'none';
          btnLive.style.display = 'inline-block';
          output.innerText += "\nЁЯЫС рдмрд╛рд░-рдмрд╛рд░ рд░реЛрдХ рд╣реЛрдиреЗ рдХреЗ рдХрд╛рд░рдг рд▓рд╛рдЗрд╡ рд░реЛрдХрд╛ рдЧрдпрд╛ред рдХреГрдкрдпрд╛ Chrome рдХреЛ рдЕрдкрдбреЗрдЯ рдХрд░реЗрдВ рдпрд╛ рдиреЙрд░реНрдорд▓ рдореЛрдб рдЖрдЬрд╝рдорд╛рдПрдБред";
          return;
        }
        // backoff delay
        restarting = true;
        const delay = RESTART_DELAYS[Math.min(restartAttempts, RESTART_DELAYS.length - 1)];
        restartAttempts++;
        setTimeout(() => {
          restarting = false;
          if (isLiveActive) safeStart(); // try start again
        }, delay);
      };

      // safe start (guards around start())
      try {
        liveRec.start();
      } catch (e) {
        // start may throw if invoked in transient state; retry shortly
        setTimeout(() => {
          try { liveRec.start(); } catch (err) { console.warn('start retry failed', err); }
        }, 300);
      }
    }

    function safeStart() {
      if (recognizing || restarting) return;
      startNewSession();
    }

    btnLive.addEventListener('click', () => {
      if (isLiveActive) return;
      isLiveActive = true;
      committedText = ""; recentFinals.clear(); recentKeys.clear();
      output.innerText = "ЁЯОз рд▓рд╛рдЗрд╡ рдмрд╛рддрдЪреАрдд рдЪрд╛рд▓реВ рд╣реИ... рдмреЛрд▓рд┐рдПред";
      btnLive.style.display = 'none';
      btnStop.style.display = 'inline-block';
      restartAttempts = 0;
      safeStart();
    });

    btnStop.addEventListener('click', () => {
      isLiveActive = false;
      try {
        if (liveRec) liveRec.stop();
      } catch (e) {}
      btnStop.style.display = 'none';
      btnLive.style.display = 'inline-block';
      output.innerText = (committedText ? committedText + "\n" : "") + "ЁЯЫС рдмрд╛рддрдЪреАрдд рд░реЛрдХ рджреА рдЧрдИред";
      output.scrollTop = output.scrollHeight;
    });

    btnErase.addEventListener('click', () => {
      committedText = "";
      recentFinals.clear(); recentKeys.clear();
      output.innerText = "рдпрд╣рд╛рдБ рдЖрдкрдХреА рдЖрд╡рд╛рдЬрд╝ рдХрд╛ рдЯреЗрдХреНрд╕реНрдЯ рджрд┐рдЦреЗрдЧрд╛...";
    });

    // keep safe if tab hidden
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && isLiveActive) {
        isLiveActive = false;
        try { if (liveRec) liveRec.stop(); } catch(e){}
        btnStop.style.display = 'none';
        btnLive.style.display = 'inline-block';
        output.innerText = (committedText ? committedText + "\n" : "") + "ЁЯЫС рдмрд╛рддрдЪреАрдд рд░реЛрдХ рджреА рдЧрдИ (рдкреГрд╖реНрда рдЫрд┐рдкрд╛)ред";
      }
    });

    // optional: expose a lightweight debug overlay when developers add #debug to URL
    if (location.hash === '#debug') {
      const dbg = document.createElement('div');
      dbg.style.position = 'fixed'; dbg.style.right = '8px'; dbg.style.bottom = '8px';
      dbg.style.background = 'rgba(0,0,0,0.6)'; dbg.style.color = '#fff'; dbg.style.padding = '6px';
      dbg.style.fontSize = '12px'; dbg.style.zIndex = 9999;
      document.body.appendChild(dbg);
      setInterval(() => {
        dbg.innerText = `live:${isLiveActive} recog:${recognizing} rest:${restarting} sess:${sessionCounter} commits:${committedText ? committedText.length : 0}`;
      }, 500);
    }

  })();
  </script>

</body>
</html>
