<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>‡§≤‡§æ‡§á‡§µ ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ (Fixed for Mobile)</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 10px;
      font-family: Arial, sans-serif;
      background: #f9f9f9;
      text-align: center;
      overflow: hidden; /* no page scroll */
    }
    h2 {
      margin: 6px 0;
      padding: 8px;
      font-size: 17px;
      background: #fff8e1;
      color: #795548;
      border-radius: 8px;
      border: 1px solid #ffe0b2;
      line-height: 1.25;
    }
    #output {
      width: 100%;
      height: 56vh;
      padding: 12px;
      background: #fff;
      border-radius: 10px;
      border: 1px solid #ccc;
      text-align: left;
      font-size: 26px;
      line-height: 1.4;
      overflow-y: auto;      /* only this scrolls */
      white-space: pre-wrap;
    }
    .controls { margin-top: 8px; }
    button {
      padding: 10px 14px;
      margin: 6px;
      font-size: 20px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      color: #fff;
    }
    #mic { background: #4caf50; }
    #live { background: #2196f3; }
    #stopLive { background: #ff9800; display: none; }
    #erase { background: #f44336; }
    .hint { margin-top:8px; font-size:13px; color:#666; }
  </style>
</head>
<body>

  <h2>üé§ ‚Äú‡§¨‡•ã‡§≤‡§ø‡§è‚Äù ‚Äî ‡§è‡§ï ‡§¨‡§æ‡§∞ ‡§¨‡•ã‡§≤‡•á‡§Ç  ‚Ä¢  üéôÔ∏è ‚Äú‡§≤‡§æ‡§á‡§µ ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§‚Äù ‚Äî ‡§≤‡§ó‡§æ‡§§‡§æ‡§∞ ‡§∏‡•Å‡§®‡•á‡§Ç</h2>

  <div id="output">‡§Ø‡§π‡§æ‡§Å ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§¶‡§ø‡§ñ‡•á‡§ó‡§æ...</div>

  <div class="controls">
    <button id="mic">üé§ ‡§¨‡•ã‡§≤‡§ø‡§è</button>
    <button id="live">üéôÔ∏è ‡§≤‡§æ‡§á‡§µ ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§</button>
    <button id="stopLive">‚èπ ‡§∞‡•ã‡§ï‡§ø‡§è</button>
    <button id="erase">üßπ ‡§Æ‡§ø‡§ü‡§æ‡§á‡§è</button>
  </div>

  <div class="hint">‡§Ø‡§¶‡§ø ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§¶‡§ø‡§ñ‡•á ‡§§‡•ã ‡§¨‡§§‡§æ‡§è‡§Ç ‚Äî ‡§Æ‡•à‡§Ç ‡§§‡•Å‡§∞‡§Ç‡§§ ‡§î‡§∞ ‡§ü‡•ç‡§Ø‡•Ç‡§® ‡§ï‡§∞ ‡§¶‡•Ç‡§Å‡§ó‡§æ‡•§</div>

  <script>
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const output = document.getElementById('output');
    const mic = document.getElementById('mic');
    const live = document.getElementById('live');
    const stopLive = document.getElementById('stopLive');
    const erase = document.getElementById('erase');

    if (!SpeechRecognition) {
      output.innerText = "‡§Ü‡§™‡§ï‡§æ ‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§∞ Speech Recognition ‡§∏‡§™‡•ã‡§∞‡•ç‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞‡§§‡§æ ‚Äî Chrome/Edge ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç‡•§";
    }

    // ---------- Single (one-shot) recognition ----------
    const singleRec = new SpeechRecognition();
    singleRec.lang = 'hi-IN';
    singleRec.interimResults = false;
    singleRec.maxAlternatives = 1;

    mic.addEventListener('click', () => {
      try {
        singleRec.start();
        output.innerText = "üéôÔ∏è ‡§Æ‡§æ‡§á‡§ï ‡§∏‡•Å‡§® ‡§∞‡§π‡§æ ‡§π‡•à...";
      } catch (e) { console.warn('singleRec start error', e); }
    });

    singleRec.onresult = (ev) => {
      const text = ev.results[0][0].transcript;
      output.innerText = text;
    };

    singleRec.onerror = (ev) => {
      output.innerText = "‚ö†Ô∏è ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: " + ev.error;
    };

    // ---------- Live continuous recognition (robust dedupe) ----------
    const liveRec = new SpeechRecognition();
    liveRec.lang = 'hi-IN';
    liveRec.interimResults = true;
    liveRec.continuous = true;

    let isLiveActive = false;
    let recognizing = false;       // true when recognition session is active
    let restarting = false;
    let committedText = "";        // final committed text visible to user
    const recentFinals = new Map(); // map: normalizedTranscript -> timestamp(ms)
    const DEDUPE_WINDOW_MS = 5000;  // ignore same final transcript within 5s

    // helper: normalize transcript for robust comparison
    function normalizeText(s) {
      return (s || '').trim().toLowerCase().replace(/\s+/g, ' ');
    }

    // cleanup old entries in recentFinals
    function cleanupFinals() {
      const now = Date.now();
      for (const [k, ts] of recentFinals.entries()) {
        if (now - ts > DEDUPE_WINDOW_MS * 2) recentFinals.delete(k);
      }
    }

    // safe start: only call start when not already recognizing
    function safeStartRecognition() {
      if (recognizing) return;
      try {
        liveRec.start();
        // start may be asynchronous; onstart will set recognizing true
      } catch (e) {
        // Chrome may throw if still in transient state ‚Äî retry shortly
        setTimeout(() => {
          try { liveRec.start(); } catch (err) { console.warn('start retry failed', err); }
        }, 300);
      }
    }

    live.addEventListener('click', () => {
      if (isLiveActive) return;
      isLiveActive = true;
      committedText = ""; // start fresh; change if you prefer append
      recentFinals.clear();
      output.innerText = "üéß ‡§≤‡§æ‡§á‡§µ ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ ‡§ö‡§æ‡§≤‡•Ç ‡§π‡•à... ‡§¨‡•ã‡§≤‡§§‡•á ‡§∞‡§π‡§ø‡§è‡•§";
      live.style.display = 'none';
      stopLive.style.display = 'inline-block';
      safeStartRecognition();
    });

    liveRec.onstart = () => {
      recognizing = true;
      // console.debug('liveRec onstart');
    };

    liveRec.onresult = (ev) => {
      // First, cleanup old cached finals
      cleanupFinals();

      let interimParts = [];
      for (let i = ev.resultIndex; i < ev.results.length; ++i) {
        const res = ev.results[i];
        const transcript = (res[0] && res[0].transcript) ? res[0].transcript.trim() : '';
        if (res.isFinal) {
          const key = normalizeText(transcript);
          const now = Date.now();
          const lastTs = recentFinals.get(key) || 0;

          // Append only if not seen recently
          if (transcript && (now - lastTs > DEDUPE_WINDOW_MS)) {
            // commit this final
            committedText += (committedText ? " " : "") + transcript;
            recentFinals.set(key, now);
          } else {
            // duplicate detected ‚Äî ignore
            // console.debug('duplicate final ignored:', transcript);
          }
        } else {
          // interim
          if (transcript) interimParts.push(transcript);
        }
      }

      // Show committed finals + interim overlay underneath
      const interimText = interimParts.length ? ("\n" + interimParts.join(' ')) : "";
      output.innerText = (committedText ? committedText : "") + interimText;
      output.scrollTop = output.scrollHeight;
    };

    liveRec.onerror = (ev) => {
      // ignore benign errors (no-speech, aborted) to avoid spam
      if (ev.error && ev.error !== 'no-speech' && ev.error !== 'aborted') {
        output.innerText += "\n‚ö†Ô∏è ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: " + ev.error;
      }
    };

    liveRec.onend = () => {
      recognizing = false;
      // Restart only if live mode still active. Use restarting guard to prevent overlap.
      if (!isLiveActive) return;
      if (restarting) return;
      restarting = true;
      // small delay gives browser time to fully terminate the previous session
      setTimeout(() => {
        restarting = false;
        if (isLiveActive) safeStartRecognition();
      }, 600); // increased a bit to be safer on S23
    };

    liveRec.onnomatch = () => {
      // no match ‚Äî ignore
    };

    liveRec.onaudioend = () => {
      // audio ended ‚Äî nothing
    };

    liveRec.onpause = () => {
      // not widely used, ignore
    };

    liveRec.onstop = () => {
      recognizing = false;
    };

    stopLive.addEventListener('click', () => {
      isLiveActive = false;
      try { liveRec.stop(); } catch (e) {}
      stopLive.style.display = 'none';
      live.style.display = 'inline-block';
      output.innerText = (committedText ? committedText + "\n" : "") + "üõë ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ ‡§∞‡•ã‡§ï ‡§¶‡•Ä ‡§ó‡§à‡•§";
      output.scrollTop = output.scrollHeight;
    });

    erase.addEventListener('click', () => {
      committedText = "";
      recentFinals.clear();
      output.innerText = "‡§Ø‡§π‡§æ‡§Å ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§¶‡§ø‡§ñ‡•á‡§ó‡§æ...";
    });

    // Safety: if browser tab becomes hidden, stop live to avoid weird behavior
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && isLiveActive) {
        // stop gracefully
        isLiveActive = false;
        try { liveRec.stop(); } catch (e) {}
        stopLive.style.display = 'none';
        live.style.display = 'inline-block';
        output.innerText = (committedText ? committedText + "\n" : "") + "üõë ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ ‡§∞‡•ã‡§ï ‡§¶‡•Ä ‡§ó‡§à (‡§™‡•É‡§∑‡•ç‡§† ‡§õ‡§ø‡§™‡§æ)‡•§";
      }
    });
  </script>
</body>
</html>
