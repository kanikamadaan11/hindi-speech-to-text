<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>‡§≤‡§æ‡§á‡§µ ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ ‚Äî (Fixed)</title>
  <style>
    * { box-sizing: border-box; }
    html,body { height:100%; margin:0; }
    body {
      margin: 0; padding: 10px; font-family: Arial, sans-serif;
      background: #f9f9f9; text-align: center; overflow: hidden;
      -webkit-tap-highlight-color: transparent;
    }
    h2 {
      margin: 6px 0; padding: 8px; font-size: 17px;
      background:#fff8e1; color:#795548; border-radius:8px;
      border:1px solid #ffe0b2; line-height:1.25;
    }
    #output {
      width:100%;
      height:56vh;
      padding:12px;
      background:#fff; border-radius:10px; border:1px solid #ccc;
      text-align:left; font-size:26px; line-height:1.4;
      overflow-y:auto; white-space:pre-wrap;
    }
    .controls { margin-top: 8px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap;}
    button {
      padding:10px 14px; font-size:18px; border-radius:8px; border:none; cursor:pointer; color:#fff;
    }
    #mic { background:#4caf50; }
    #live { background:#2196f3; }
    #stopLive { background:#ff9800; display:none; }
    #erase { background:#f44336; }
    .small { padding:8px 12px; font-size:16px; }
    .footer { margin-top:6px; font-size:13px; color:#666; }
    pre.debug { font-size:12px; color:#111; background:#fff; padding:8px; max-height:10vh; overflow:auto; border-radius:6px; border:1px dashed #ddd; display:none; }
    @media (max-width:420px){
      #output { font-size:20px; height:60vh; }
      button { font-size:16px; padding:8px 12px; }
    }
  </style>
</head>
<body>

  <h2>üé§ ‚Äú‡§¨‡•ã‡§≤‡§ø‡§è‚Äù ‚Äî ‡§è‡§ï ‡§¨‡§æ‡§∞ ‡§¨‡•ã‡§≤‡•á‡§Ç ‚Ä¢ üéôÔ∏è ‚Äú‡§≤‡§æ‡§á‡§µ ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§‚Äù ‚Äî ‡§≤‡§ó‡§æ‡§§‡§æ‡§∞ ‡§∏‡•Å‡§®‡•á‡§Ç</h2>

  <div id="output">‡§Ø‡§π‡§æ‡§Å ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§¶‡§ø‡§ñ‡•á‡§ó‡§æ...</div>

  <div class="controls">
    <button id="mic">üé§ ‡§¨‡•ã‡§≤‡§ø‡§è</button>
    <button id="live">üéôÔ∏è ‡§≤‡§æ‡§á‡§µ ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§</button>
    <button id="stopLive">‚èπ ‡§∞‡•ã‡§ï‡§ø‡§è</button>
    <button id="erase" class="small">üßπ ‡§Æ‡§ø‡§ü‡§æ‡§á‡§è</button>
  </div>

  <div class="footer">¬© Speech to Text (Hindi)</div>

  <!-- Debug block: add #debug to URL to view -->
  <pre id="debug" class="debug"></pre>

<script>
(function(){
  const out = document.getElementById('output');
  const micBtn = document.getElementById('mic');
  const liveBtn = document.getElementById('live');
  const stopBtn = document.getElementById('stopLive');
  const eraseBtn = document.getElementById('erase');
  const debugEl = document.getElementById('debug');
  const ENABLE_DEBUG = location.hash === '#debug';

  if (ENABLE_DEBUG) debugEl.style.display = 'block';

  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SpeechRecognition) {
    out.innerText = "‡§Ø‡§π ‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§∞ Speech Recognition ‡§∏‡§™‡•ã‡§∞‡•ç‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞‡§§‡§æ ‚Äî ‡§ï‡•É‡§™‡§Ø‡§æ Chrome/Edge ‡§™‡•ç‡§∞‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç‡•§";
    micBtn.disabled = liveBtn.disabled = stopBtn.disabled = eraseBtn.disabled = true;
    return;
  }

  // -------- utility: Levenshtein distance & similarity -----------
  function levenshtein(a, b) {
    a = (a||'').toLowerCase(); b = (b||'').toLowerCase();
    const la = a.length, lb = b.length;
    if (la === 0) return lb;
    if (lb === 0) return la;
    const v0 = new Array(lb + 1), v1 = new Array(lb + 1);
    for (let j = 0; j <= lb; j++) v0[j] = j;
    for (let i = 0; i < la; i++) {
      v1[0] = i + 1;
      for (let j = 0; j < lb; j++) {
        const cost = a[i] === b[j] ? 0 : 1;
        v1[j + 1] = Math.min(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost);
      }
      for (let j = 0; j <= lb; j++) v0[j] = v1[j];
    }
    return v1[lb];
  }
  function similarity(a,b){
    a = (a||'').trim(); b = (b||'').trim();
    if (!a && !b) return 1;
    if (!a || !b) return 0;
    const d = levenshtein(a,b);
    const maxLen = Math.max(a.length, b.length);
    if (maxLen === 0) return 1;
    return 1 - d / maxLen;
  }

  // ---------- Single-shot recognition (original behavior) ----------
  const singleRec = new SpeechRecognition();
  singleRec.lang = 'hi-IN';
  singleRec.interimResults = false;
  singleRec.maxAlternatives = 1;

  singleRec.onstart = () => {
    // show status
    out.innerText = "üéôÔ∏è ‡§Æ‡§æ‡§á‡§ï ‡§∏‡•Å‡§® ‡§∞‡§π‡§æ ‡§π‡•à...";
  };
  singleRec.onresult = (ev) => {
    try {
      const t = ev.results[0][0].transcript;
      out.innerText = t;
    } catch(e) { console.warn(e); }
  };
  singleRec.onerror = (ev) => {
    out.innerText = "‚ö†Ô∏è ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: " + (ev && ev.error ? ev.error : 'unknown');
  };

  micBtn.addEventListener('click', () => {
    try { singleRec.start(); } catch(e) { console.warn(e); }
  });

  // ---------- Live continuous recognition with robust dedupe ----------
  // We'll create fresh recognizer sessions to isolate state
  let liveRec = null;
  let liveSessionId = 0;
  let isLiveActive = false;
  let recognizing = false;
  let restarting = false;
  let committedText = "";             // final appended text
  const recentFinals = new Map();     // normalized -> timestamp
  const recentKeys = new Set();       // sessionKey (norm|index|session)
  const MAX_RESTARTS = 10;
  let restartCount = 0;

  const DEDUPE_WINDOW_MS = 4500;      // time window to suppress repeats
  const BACKOFF_BASE = 400;

  function normalize(s){ return (s||'').trim().replace(/\s+/g,' ').toLowerCase(); }

  function makeLiveRecognizer(sessionId){
    const r = new SpeechRecognition();
    r.lang = 'hi-IN';
    r.interimResults = true;
    r.continuous = true; // request continuous; mobile may not fully honor but we handle restarts
    r._sid = sessionId;
    return r;
  }

  function cleanupCaches(){
    const now = Date.now();
    for (const [k,ts] of recentFinals.entries()){
      if (now - ts > DEDUPE_WINDOW_MS * 3) recentFinals.delete(k);
    }
    if (recentKeys.size > 1000){
      // trim oldest: not trivial with Set; recreate with last 300
      const items = Array.from(recentKeys);
      recentKeys.clear();
      items.slice(-300).forEach(x => recentKeys.add(x));
    }
  }

  function startLiveSession(){
    if (recognizing || restarting) return;
    liveSessionId += 1;
    const sid = liveSessionId;
    liveRec = makeLiveRecognizer(sid);

    liveRec.onstart = () => { recognizing = true; restarting = false; restartCount = 0; debug('onstart', sid); };
    liveRec.onresult = (ev) => {
      cleanupCaches();
      try {
        let interimParts = [];
        for (let i = ev.resultIndex; i < ev.results.length; ++i){
          const res = ev.results[i];
          const txt = res[0] && res[0].transcript ? res[0].transcript.trim() : '';
          if (res.isFinal){
            const norm = normalize(txt);
            const key = `${norm}|${i}|${sid}`;
            const now = Date.now();
            const lastTs = recentFinals.get(norm) || 0;
            // check if this exact session+index already processed
            if (recentKeys.has(key)){
              // duplicate by key - ignore
              debug('dup-key', key);
              continue;
            }
            // check if similar final was seen within window
            let seenSimilar = false;
            for (const [existingNorm, ts] of recentFinals.entries()){
              if (now - ts <= DEDUPE_WINDOW_MS){
                if (similarity(existingNorm, norm) >= 0.88){ seenSimilar = true; break; }
              }
            }
            // Also check against last committed chunk (end)
            const lastCommittedChunk = (committedText.split(/\s{1,}/).slice(-6).join(' ')) || '';
            const simLast = similarity(lastCommittedChunk, txt);

            if (!recentKeys.has(key) && !seenSimilar && simLast < 0.92) {
              // Accept and commit
              committedText += (committedText ? ' ' : '') + txt;
              recentFinals.set(norm, now);
              recentKeys.add(key);
              debug('commit', txt, 'sid', sid, 'idx', i);
            } else {
              // it's a duplicate / very similar; ignore to avoid repeating
              debug('ignored-final', txt, 'sid', sid, 'idx', i, { seenSimilar, simLast });
              // still mark key so if same fires again we ignore
              recentKeys.add(key);
            }
          } else {
            if (txt) interimParts.push(txt);
          }
        }

        const interimText = interimParts.length ? ("\n" + interimParts.join(' ')) : "";
        out.innerText = (committedText ? committedText : "") + interimText;
        out.scrollTop = out.scrollHeight;
      } catch (e) { console.warn('onresult error', e); }
    };

    liveRec.onerror = (ev) => {
      debug('onerror', ev && ev.error);
      // Silently ignore 'no-speech' / 'aborted' to reduce spam
      if (ev && ev.error && ev.error !== 'no-speech' && ev.error !== 'aborted') {
        // show short error to user but do not stop attempts
        out.innerText += "\n‚ö†Ô∏è ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: " + ev.error;
      }
    };

    liveRec.onend = () => {
      recognizing = false;
      debug('onend', sid);
      if (!isLiveActive) return;
      // Backoff restart but avoid overlapping
      if (restartCount >= MAX_RESTARTS){
        isLiveActive = false;
        stopBtn.style.display = 'none';
        liveBtn.style.display = 'inline-block';
        out.innerText += "\nüõë ‡§¨‡§æ‡§∞-‡§¨‡§æ‡§∞ ‡§∏‡•ç‡§ü‡•â‡§™ ‡§π‡•ã‡§®‡•á ‡§ï‡•á ‡§ï‡§æ‡§∞‡§£ ‡§≤‡§æ‡§á‡§µ ‡§∞‡•ã‡§ï‡§æ ‡§ó‡§Ø‡§æ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§ê‡§™ ‡§∞‡•Ä‡§´‡§º‡•ç‡§∞‡•á‡§∂ ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ ‡§°‡§ø‡§µ‡§æ‡§á‡§∏ ‡§∞‡•Ä‡§∏‡•ç‡§ü‡§æ‡§∞‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§";
        return;
      }
      restarting = true;
      restartCount += 1;
      const delay = BACKOFF_BASE * Math.min(restartCount, 6);
      debug('restart after', delay);
      setTimeout(() => {
        restarting = false;
        if (isLiveActive) safeStartLive();
      }, delay);
    };

    // Try start (guarded)
    try {
      liveRec.start();
    } catch (e) {
      // if start throws, retry shortly
      setTimeout(() => {
        try { liveRec.start(); } catch (err) { console.warn('start retry failed', err); }
      }, 300);
    }
  } // end startLiveSession

  function safeStartLive(){
    if (recognizing || restarting) return;
    startLiveSession();
  }

  liveBtn.addEventListener('click', () => {
    if (isLiveActive) return;
    isLiveActive = true;
    committedText = ""; recentFinals.clear(); recentKeys.clear();
    out.innerText = "üéß ‡§≤‡§æ‡§á‡§µ ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ ‡§ö‡§æ‡§≤‡•Ç ‡§π‡•à... ‡§¨‡•ã‡§≤‡§ø‡§è‡•§";
    liveBtn.style.display = 'none';
    stopBtn.style.display = 'inline-block';
    restartCount = 0;
    safeStartLive();
  });

  stopBtn.addEventListener('click', () => {
    isLiveActive = false;
    try { if (liveRec) liveRec.stop(); } catch(e){}
    stopBtn.style.display = 'none';
    liveBtn.style.display = 'inline-block';
    out.innerText = (committedText ? committedText + "\n" : "") + "üõë ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ ‡§∞‡•ã‡§ï ‡§¶‡•Ä ‡§ó‡§à‡•§";
  });

  eraseBtn.addEventListener('click', () => {
    committedText = "";
    recentFinals.clear(); recentKeys.clear();
    out.innerText = "‡§Ø‡§π‡§æ‡§Å ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§¶‡§ø‡§ñ‡•á‡§ó‡§æ...";
  });

  // small debug helper
  function debug(...args){
    if (!ENABLE_DEBUG) return;
    console.log(...args);
    try {
      debugEl.textContent = (debugEl.textContent + '\n' + args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' | ')).slice(-4000);
      debugEl.scrollTop = debugEl.scrollHeight;
    } catch(e){}
  }

  // stop live if the tab hides (prevents weird background duplicates)
  document.addEventListener('visibilitychange', () => {
    if (document.hidden && isLiveActive){
      isLiveActive = false;
      try { if (liveRec) liveRec.stop(); } catch(e){}
      stopBtn.style.display = 'none';
      liveBtn.style.display = 'inline-block';
      out.innerText = (committedText ? committedText + "\n" : "") + "üõë ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ ‡§∞‡•ã‡§ï ‡§¶‡•Ä ‡§ó‡§à (‡§™‡•É‡§∑‡•ç‡§† ‡§õ‡§ø‡§™‡§æ)‡•§";
    }
  });

  // Safety: small warm-up test to detect Chrome duplicates (optional)
 

})(); // IIFE
</script>

</body>
</html>
