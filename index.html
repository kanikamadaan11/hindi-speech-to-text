<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="UTF-8">
  <title>Speech to Text (Hindi)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="theme-color" content="#4caf50">
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 10px;
      font-family: Arial, sans-serif;
      background:#f9f9f9; text-align:center;
      overflow: hidden; /* prevent whole-page scroll */
    }
    h2 {
      margin: 4px 0 10px;
      padding: 8px;
      font-size: 17px;
      background:#fff8e1; color:#795548;
      border-radius:8px; border:1px solid #ffe0b2;
      line-height:1.25;
    }
    #output {
      width:100%;
      height:56vh;
      padding:12px;
      background:#fff;
      border-radius:10px;
      border:1px solid #ccc;
      font-size:26px;
      line-height:1.4;
      text-align:left;
      overflow-y:auto; /* only this scrolls */
      white-space:pre-wrap;
    }
    .controls { margin-top:8px; }
    button {
      padding:10px 16px;
      margin:6px;
      font-size:20px;
      border-radius:8px;
      border:none;
      cursor:pointer;
    }
    #mic { background:#4caf50; color:#fff; }
    #live { background:#2196f3; color:#fff; }
    #stopLive { background:#ff9800; color:#fff; display:none; }
    #erase { background:#f44336; color:#fff; }
    .footer { margin-top:8px; color:#666; font-size:13px; }
  </style>
</head>
<body>

  <h2>üé§ ‚Äú‡§¨‡•ã‡§≤‡§ø‡§è‚Äù ‚Äî ‡§è‡§ï ‡§¨‡§æ‡§∞ ‡§¨‡•ã‡§≤‡•á‡§Ç  ‚Ä¢  üéôÔ∏è ‚Äú‡§≤‡§æ‡§á‡§µ ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§‚Äù ‚Äî ‡§≤‡§ó‡§æ‡§§‡§æ‡§∞ ‡§∏‡•Å‡§®‡•á‡§Ç</h2>

  <div id="output">‡§Ø‡§π‡§æ‡§Å ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§¶‡§ø‡§ñ‡•á‡§ó‡§æ...</div>

  <div class="controls">
    <button id="mic">üé§ ‡§¨‡•ã‡§≤‡§ø‡§è</button>
    <button id="live">üéôÔ∏è ‡§≤‡§æ‡§á‡§µ ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§</button>
    <button id="stopLive">‚èπ ‡§∞‡•ã‡§ï‡§ø‡§è</button>
    <button id="erase">üßπ ‡§Æ‡§ø‡§ü‡§æ‡§á‡§è</button>
  </div>

  <div class="footer">¬© Speech to Text (Hindi)</div>

  <script>
    const output = document.getElementById('output');
    const micBtn = document.getElementById('mic');
    const liveBtn = document.getElementById('live');
    const stopLiveBtn = document.getElementById('stopLive');
    const eraseBtn = document.getElementById('erase');

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      output.innerText = "‡§Ü‡§™‡§ï‡§æ ‡§¨‡•ç‡§∞‡§æ‡§â‡§ú‡§º‡§∞ Speech Recognition ‡§ï‡•ã ‡§∏‡§™‡•ã‡§∞‡•ç‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞‡§§‡§æ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ Chrome/Edge ‡§™‡•ç‡§∞‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç‡•§";
    }

    // One-time (single) recognition
    const singleRec = new SpeechRecognition();
    singleRec.lang = 'hi-IN';
    singleRec.interimResults = false;
    singleRec.maxAlternatives = 1;

    micBtn.addEventListener('click', () => {
      try {
        singleRec.start();
        output.innerText = "üéôÔ∏è ‡§Æ‡§æ‡§á‡§ï ‡§∏‡•Å‡§® ‡§∞‡§π‡§æ ‡§π‡•à...";
      } catch (e) {
        console.error(e);
      }
    });

    singleRec.onresult = (ev) => {
      output.innerText = ev.results[0][0].transcript;
    };
    singleRec.onerror = (ev) => {
      output.innerText = "‚ö†Ô∏è ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: " + ev.error;
    };

    // Live continuous recognition (mobile-friendly, deduplicated)
    const liveRec = new SpeechRecognition();
    liveRec.lang = 'hi-IN';
    liveRec.interimResults = true;   // show interim but commit final only
    liveRec.continuous = true;      // request continuous (may not be honored on all mobiles)

    let isLiveActive = false;
    let restarting = false;
    let committedText = "";         // all confirmed final text
    let lastFinalSegment = "";      // last appended final segment (for dedupe)

    liveBtn.addEventListener('click', () => {
      if (!isLiveActive) {
        isLiveActive = true;
        committedText = "";        // start fresh or keep existing? you can change if you want to append instead
        lastFinalSegment = "";
        output.innerText = "üéß ‡§≤‡§æ‡§á‡§µ ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ ‡§ö‡§æ‡§≤‡•Ç ‡§π‡•à... ‡§¨‡•ã‡§≤‡§§‡•á ‡§∞‡§π‡§ø‡§è‡•§";
        liveBtn.style.display = 'none';
        stopLiveBtn.style.display = 'inline-block';
        startLiveSafely();
      }
    });

    function startLiveSafely() {
      // ensure we don't call start when it's still in stopping/starting transient
      try {
        liveRec.start();
      } catch (e) {
        // Chrome may throw if start called while already starting - retry shortly
        setTimeout(() => {
          try { liveRec.start(); } catch (err) { /* ignore */ }
        }, 300);
      }
    }

    liveRec.onresult = (ev) => {
      // Build interim + finals but commit only final segments (isFinal)
      // This avoids duplicates ‚Äî final segments get appended once.
      let interim = "";
      for (let i = ev.resultIndex; i < ev.results.length; ++i) {
        const res = ev.results[i];
        const text = res[0].transcript.trim();
        if (res.isFinal) {
          // commit this final result if it's not same as last committed final segment
          if (text && text !== lastFinalSegment) {
            // Append to committed text with spacing
            if (committedText && !committedText.endsWith("\n")) committedText += " ";
            committedText += text;
            lastFinalSegment = text;
          }
        } else {
          // build the interim overlay (not committed)
          interim += text + " ";
        }
      }

      // Show combined: committed (finals) + interim
      output.innerText = committedText + (interim ? ("\n" + interim.trim()) : "");
      // scroll to bottom
      output.scrollTop = output.scrollHeight;
    };

    liveRec.onerror = (ev) => {
      // ignore "no-speech" and "aborted" quietly to avoid spam,
      // show others so user knows something's wrong.
      if (ev.error && ev.error !== "no-speech" && ev.error !== "aborted") {
        output.innerText += "\n‚ö†Ô∏è ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: " + ev.error;
      }
    };

    // onend: restart only when live is active, with guard to avoid overlap
    liveRec.onend = () => {
      if (!isLiveActive) return;
      if (restarting) return;
      restarting = true;
      // small delay ensures previous session fully ended on mobile before starting again
      setTimeout(() => {
        restarting = false;
        if (isLiveActive) {
          startLiveSafely();
        }
      }, 350);
    };

    stopLiveBtn.addEventListener('click', () => {
      isLiveActive = false;
      try { liveRec.stop(); } catch (e) { /* ignore */ }
      stopLiveBtn.style.display = 'none';
      liveBtn.style.display = 'inline-block';
      output.innerText = (committedText ? committedText : "") + "\nüõë ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ ‡§∞‡•ã‡§ï ‡§¶‡•Ä ‡§ó‡§à‡•§";
      output.scrollTop = output.scrollHeight;
    });

    eraseBtn.addEventListener('click', () => {
      committedText = "";
      lastFinalSegment = "";
      output.innerText = "‡§Ø‡§π‡§æ‡§Å ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§¶‡§ø‡§ñ‡•á‡§ó‡§æ...";
    });

    // Optional: keep screen awake? Not included to keep browser compatibility simple.
  </script>

</body>
</html>
